---
## Project Overview

**Project Name**: MiMiVibes - AI-Powered Tarot Reading Platform

**Repository**: https://github.com/mojisejr/mimivibe-ai.git

**Description**: ‡πÅ‡∏û‡∏•‡∏ï‡∏ü‡∏≠‡∏£‡πå‡∏°‡∏î‡∏π‡πÑ‡∏û‡πà‡∏ó‡∏≤‡πÇ‡∏£‡∏ï‡πå‡∏≠‡∏≠‡∏ô‡πÑ‡∏•‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏Ç‡∏±‡∏ö‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏î‡πâ‡∏ß‡∏¢ AI ‡πÉ‡∏´‡πâ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡πÅ‡∏ö‡∏ö‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏±‡∏ß‡∏ú‡πà‡∏≤‡∏ô "‡πÅ‡∏°‡πà‡∏´‡∏°‡∏≠‡∏°‡∏µ‡∏°‡∏µ‡πà" ‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡∏µ‡πà‡∏¢‡∏ß‡∏ä‡∏≤‡∏ç‡∏î‡πâ‡∏≤‡∏ô‡πÑ‡∏û‡πà‡∏ó‡∏≤‡πÇ‡∏£‡∏ï‡πå AI ‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏ä‡πâ‡πÄ‡∏ó‡∏Ñ‡πÇ‡∏ô‡πÇ‡∏•‡∏¢‡∏µ Multi-LLM (OpenAI GPT-4 + Google Gemini) ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö LangGraph workflow ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏ò‡∏£‡∏£‡∏°‡∏ä‡∏≤‡∏ï‡∏¥

**Project Goals**:

- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡∏™‡∏ö‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡πÑ‡∏û‡πà‡∏ó‡∏≤‡πÇ‡∏£‡∏ï‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡πÑ‡∏î‡πâ‡∏á‡πà‡∏≤‡∏¢ ‡∏ô‡πà‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏ñ‡∏∑‡∏≠ ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏ó‡∏Ñ‡πÇ‡∏ô‡πÇ‡∏•‡∏¢‡∏µ AI
- ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏î‡πâ‡∏ß‡∏¢‡∏£‡∏∞‡∏ö‡∏ö Multi-LLM ‡πÅ‡∏•‡∏∞ LangGraph workflow
- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡πÑ‡∏î‡πâ‡∏ó‡∏µ‡πà‡∏¢‡∏±‡πà‡∏á‡∏¢‡∏∑‡∏ô‡∏ú‡πà‡∏≤‡∏ô‡∏£‡∏∞‡∏ö‡∏ö credit ‡πÅ‡∏•‡∏∞ gamification ‡∏Ñ‡∏£‡∏ö‡∏Ñ‡∏£‡∏±‡∏ô
- ‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡πÅ‡∏•‡∏∞‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏ñ‡∏∑‡∏≠‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏î‡πâ‡∏ß‡∏¢‡∏£‡∏∞‡∏ö‡∏ö‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏≠‡∏á‡∏Ñ‡πå‡∏Å‡∏£

---

### Development Guidelines

**‚ö†Ô∏è CRITICAL: Synchronize Time Before Any File Operations**

Before creating a new file or saving any timestamps, you **MUST** use the following command to retrieve the current date and time from the system:

```bash
date +"%Y-%m-%d %H:%M:%S"
```

This ensures accurate timestamp synchronization with the system clock and prevents time-related inconsistencies.

#### File Naming Conventions

- **Retrospective Files**: `session-YYYY-MM-DD-[description].md`
- **Log Files**: `YYYY-MM-DD-[type].log`
- **Backup Files**: `backup-YYYY-MM-DD-HHMM.sql`

#### Important Notes

- **ALL timestamps** in documentation, logs, and file names must use Thailand timezone
- **Year format** must always be Christian Era (‡∏Ñ.‡∏®.) not Buddhist Era (‡∏û.‡∏®.)
- **Development sessions** should reference Thailand local time
- **Retrospective files** must use correct Thailand date in filename

---

## Architecture Overview

### Core Structure

- **Framework**: Next.js 14 (App Router)
- **Frontend/Framework**: React 18 with TypeScript (Strict Mode)
- **API Layer**: Next.js API Routes (39+ endpoints)
- **Database**: PostgreSQL (Production) / SQLite (Development) with Prisma ORM
- **File Storage**: Vercel Static Assets
- **Styling**: Tailwind CSS with Framer Motion animations
- **Authentication**: Clerk Auth (Multi-provider support)
- **Data Validation**: Zod with custom validation schemas

### Tech Stack

- **Frontend**: Next.js 14, React 18, TypeScript, Tailwind CSS, Framer Motion, Clerk Auth
- **Backend**: Node.js (Vercel Serverless), Prisma ORM, PostgreSQL, Stripe Payments
- **AI Integration**: OpenAI GPT-4-turbo, Google Gemini 2.0 Flash, LangGraph workflow engine
- **Database**: PostgreSQL via Vercel/Supabase with Prisma migrations
- **File Storage**: Vercel Edge Network CDN
- **Authentication**: Clerk with Google, Facebook, Email providers

### Backend API Routes

- **Reading System** (`/api/readings/`): Core tarot reading functionality

  - `ask.ts`: Generate new tarot readings with AI workflow
  - `save.ts`: Save completed readings to user history
  - `history.ts`: Retrieve user's reading history with pagination

- **User Management** (`/api/user/`): User profile and progression

  - `stats.ts`: User statistics, level, and experience tracking
  - `credits.ts`: Credit balance management (stars, coins, free points)
  - `level-check.ts`: Level progression and prestige system
  - `prestige.ts`: Prestige system for level 100+ users

- **Payment System** (`/api/payments/`): Stripe integration

  - `create-payment-intent.ts`: Stripe payment processing
  - `webhook.ts`: Stripe webhook for payment confirmations
  - `history.ts`: Payment transaction history

- **Gamification** (`/api/achievements/`, `/api/credits/`): Achievement and reward system

  - `progress.ts`: Track user achievement progress
  - `claim.ts`: Claim earned achievements
  - `spend.ts`: Process credit spending transactions

- **Admin System** (`/api/admin/`): Administrative functions
  - Campaign management, user analytics, system monitoring

### Frontend User Journeys

- **User Journey Flows**:
  - **Tarot Reading Flow**: Landing ‚Üí Sign Up/Login ‚Üí Ask Question ‚Üí Card Selection ‚Üí AI Generation ‚Üí Reading Display ‚Üí Save/Share
  - **Payment Flow**: Credit Check ‚Üí Package Selection ‚Üí Stripe Payment ‚Üí Credit Addition ‚Üí Confirmation
  - **Gamification Flow**: Complete Actions ‚Üí Earn XP/Coins ‚Üí Level Up ‚Üí Unlock Achievements ‚Üí Exchange Coins ‚Üí Prestige System
  - **History Management**: Reading History ‚Üí Search/Filter ‚Üí Detail View ‚Üí Delete/Favorite ‚Üí Export Options

---

## ü§ñ AI System Architecture

### LangGraph Workflow (4-Node State Machine)

1. **Question Filter Node**: ‡∏Ñ‡∏±‡∏î‡∏Å‡∏£‡∏≠‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°, ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡πÅ‡∏•‡∏∞‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô
2. **Question Analysis Node**: ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏≠‡∏≤‡∏£‡∏°‡∏ì‡πå (mood), ‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠ (topic), ‡πÅ‡∏•‡∏∞‡∏Å‡∏£‡∏≠‡∏ö‡πÄ‡∏ß‡∏•‡∏≤ (period)
3. **Card Selection Node**: ‡∏™‡∏∏‡πà‡∏°‡πÑ‡∏û‡πà‡∏à‡∏≤‡∏Å‡∏™‡∏≥‡∏£‡∏±‡∏ö Rider-Waite (78 ‡πÉ‡∏ö) ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö 3-5 ‡πÉ‡∏ö
4. **Reading Generation Node**: ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏î‡πâ‡∏ß‡∏¢‡∏ö‡∏∏‡∏Ñ‡∏•‡∏¥‡∏Å "‡πÅ‡∏°‡πà‡∏´‡∏°‡∏≠‡∏°‡∏µ‡∏°‡∏µ‡πà"

### Multi-LLM Provider System

- **Primary Provider**: OpenAI GPT-4-turbo (default)
- **Fallback Provider**: Google Gemini 2.0 Flash
- **Provider Abstraction**: LLMProvider interface with automatic fallback
- **Token Limits**: 4096 tokens for complex readings
- **Prompt Management**: Encrypted prompt system with version control

### Prompt Templates

- **Question Filter**: ‡∏Ñ‡∏±‡∏î‡∏Å‡∏£‡∏≠‡∏á‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢
- **Question Analysis**: ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ö‡∏£‡∏¥‡∏ö‡∏ó‡πÅ‡∏•‡∏∞‡∏≠‡∏≤‡∏£‡∏°‡∏ì‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°
- **Reading Agent**: ‡∏ö‡∏∏‡∏Ñ‡∏•‡∏¥‡∏Å "‡πÅ‡∏°‡πà‡∏´‡∏°‡∏≠‡∏°‡∏µ‡∏°‡∏µ‡πà" ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏≠‡∏ö‡∏≠‡∏∏‡πà‡∏ô‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏±‡∏ô‡πÄ‡∏≠‡∏á

---

## üí≥ Payment & Credit System

### Credit Types

- **Stars (‚≠ê)**: ‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏µ‡πà‡∏ã‡∏∑‡πâ‡∏≠‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏á‡∏¥‡∏ô‡∏à‡∏£‡∏¥‡∏á (1 star = 1 reading)
- **Free Points (üéÅ)**: ‡πÄ‡∏Ñ‡∏£‡∏î‡∏¥‡∏ï‡∏ü‡∏£‡∏µ‡∏à‡∏≤‡∏Å‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡πÅ‡∏•‡∏∞ achievements
- **Coins (ü™ô)**: ‡∏™‡∏Å‡∏∏‡∏•‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏Å‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏•‡∏Å‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô (15 coins = 1 free point)

### Stripe Integration

- **Currency**: Thai Baht (THB)
- **Packages**: Starter (99 THB/10 credits), Popular (199 THB/25 credits), Premium (399 THB/60 credits)
- **Webhook**: Real-time payment status updates
- **Security**: PCI DSS compliant with secure payment processing

---

## üéÆ Gamification System

### Level & Experience System

- **Level Progression**: level \* 100 EXP required per level
- **Max Level**: 100 (Prestige system available)
- **EXP Sources**: Readings (+10), Reviews (+5), Achievements (variable)
- **Prestige**: Reset to level 1 with permanent bonuses at level 100

### Achievement System (20 Achievements)

- **Reading Milestones**: FIRST_READING, READING_MASTER, ULTIMATE_MASTER
- **Engagement**: REVIEWER, SOCIAL_BUTTERFLY, REFERRAL_MASTER
- **Progression**: LEVEL_ACHIEVER, PRESTIGE_PIONEER
- **Special**: EARLY_BIRD, WEEKEND_WARRIOR, NIGHT_OWL

### Exchange System

- **Uniswap-style Interface**: Modern crypto-inspired design
- **Exchange Rate**: 15 coins = 1 free point
- **Transaction History**: Complete exchange tracking

---

## ‚ö†Ô∏è CRITICAL SAFETY RULES

### NEVER MERGE PRS YOURSELF

**DO NOT** use any commands to merge Pull Requests, such as `gh pr merge`. Your role is to create a well-documented PR and provide the link to the user.

**ONLY** provide the PR link to the user and **WAIT** for explicit user instruction to merge. The user will review and merge when ready.

### DO NOT DELETE CRITICAL FILES

You are **FORBIDDEN** from deleting or moving critical files and directories in the project. This includes, but is not limited to: `.env`, `.git/`, `node_modules/`, `package.json`, `prisma/schema.prisma`, and the main project root files. If a file or directory needs to be removed, you must explicitly ask for user permission and provide a clear explanation.

### HANDLE SENSITIVE DATA WITH CARE

You must **NEVER** include sensitive information such as API keys, passwords, or user data in any commit messages, Pull Request descriptions, or public logs. Always use environment variables for sensitive data. If you detect sensitive data, you must alert the user and **REFUSE** to proceed until the information is properly handled.

**Critical Environment Variables**:

- `DATABASE_URL`, `CLERK_SECRET_KEY`, `STRIPE_SECRET_KEY`
- `OPENAI_API_KEY`, `GOOGLE_GENERATIVE_AI_API_KEY`
- `PROMPT_ENCRYPTION_KEY`, `STRIPE_WEBHOOK_SECRET`

### STICK TO THE SCOPE

You are instructed to focus **ONLY** on the task described in the assigned Issue. Do not perform any refactoring, code cleanup, or new feature development unless it is explicitly part of the plan. If you encounter an opportunity to improve the code outside of the current scope, you must create a new task and discuss it with the user first.

### AI SYSTEM SAFETY

**DO NOT** modify AI prompts or LangGraph workflow without explicit permission. The prompt system uses AES-256-GCM encryption and version control. Any changes to AI behavior must be thoroughly tested using the prompt test runner (`npm run prompt:test`).

---

## üöÄ Development Workflows

### The Two-Issue Pattern

This project uses a Two-Issue Pattern to separate work context from actionable plans, integrating local workflows with GitHub Issues for clarity and traceability.

- **Context Issues (`=fcs`):** Used to record the current state and context of a session on GitHub.

- **Task Issues (`=plan`):** Used to create a detailed and comprehensive plan of action on GitHub. The agent will use information from the latest Context Issue as a reference.

---

### Shortcut Commands

These commands are standard across all projects and streamline our communication with **AUTOMATED WORKFLOW INTEGRATION**.

- **`=fcs > [message]`**: Updates the `current-focus.md` file on the local machine and creates a **GitHub Context Issue** with the specified `[message]` as the title. **WARNING**: This command will only work if there are no open GitHub issues. If there are, the agent will alert you to clear the backlog before you can save a new context. To bypass this check, use the command `=fcs -f > [message]`.

- **`=plan > [question/problem]`**: Creates a **GitHub Task Issue** with a detailed and comprehensive plan of action. The agent will use all the information from the `current-focus.md` file and previous conversations to create this Issue. If an open Task Issue already exists, the agent will **update** that Issue with the latest information instead of creating a new one.

- **`=impl > [message]`**: **ENHANCED WITH AUTOMATED WORKFLOW** - Instructs the agent to execute the plan contained in the latest **GitHub Task Issue** with full automation:

  1. **Auto-Branch Creation**: Creates feature branch with proper naming (`feature/[issue-number]-[description]`)
  2. **Implementation**: Executes the planned work
  3. **Auto-Commit & Push**: Commits changes with descriptive messages and pushes to remote
  4. **Auto-PR Creation**: Creates Pull Request with proper description and issue references
  5. **Issue Updates**: Updates the plan issue with PR link and completion status
  6. **User Notification**: Provides PR link for review and approval

- **`=rrr > [message]`**: Creates a daily Retrospective file in the `docs/retrospective/` folder and creates a GitHub Issue containing a summary of the work, an AI Diary, and Honest Feedback, allowing you and the team to review the session accurately.

### üîÑ Plan Issue Management Guidelines

**CRITICAL**: For large, multi-phase projects, the agent must **UPDATE** existing plan issues instead of creating new ones.

- **When completing phases**: Update the plan issue to reflect completed phases and mark them as ‚úÖ COMPLETED
- **Progress tracking**: Update the issue description with current status, next steps, and any blockers
- **Phase completion**: When a phase is finished, update the plan issue immediately before moving to the next phase
- **Never create new issues**: For ongoing multi-phase work, always update the existing plan issue (#20 for current system refactor)
- **Retrospective issues**: Only create retrospective issues for session summaries, not for plan updates

### üéØ Enhanced Implementation Workflows

*Based on insights from retrospective analysis showing dramatic efficiency improvements*

#### Multi-Phase Implementation Strategy

**Proven 5-Phase Approach** (from successful 15-34 minute sessions):

```
Phase 1: Analysis & Preparation (5-8 minutes)
‚îú‚îÄ Component structure analysis
‚îú‚îÄ Integration point identification  
‚îú‚îÄ Dependency mapping
‚îî‚îÄ Success criteria definition

Phase 2: Core Implementation (8-15 minutes)
‚îú‚îÄ Primary code changes
‚îú‚îÄ Component modifications
‚îú‚îÄ API updates
‚îî‚îÄ Database operations

Phase 3: Integration & Testing (3-8 minutes)
‚îú‚îÄ Build validation
‚îú‚îÄ TypeScript compilation
‚îú‚îÄ Functional testing
‚îî‚îÄ Error resolution

Phase 4: Documentation & PR (2-5 minutes)
‚îú‚îÄ Commit preparation
‚îú‚îÄ Pull request creation
‚îú‚îÄ Issue updates
‚îî‚îÄ Documentation

Phase 5: Cleanup & Review (1-2 minutes)
‚îú‚îÄ Temporary file cleanup
‚îú‚îÄ Final validation
‚îî‚îÄ Status communication
```

#### Reference Pattern Implementation

**When Following Proven Patterns** (56% efficiency improvement proven):

1. **Identify Reference Session**: Look for similar work in `/docs/retrospective/`
2. **Extract Implementation Steps**: Follow the proven methodology exactly
3. **Adapt Context-Specific Elements**: Modify only what's necessary for the new context
4. **Track Time Improvements**: Measure and document efficiency gains

#### Branch Management Excellence

**Critical Workflow Adherence** (learned from workflow violations):

```bash
# ALWAYS create feature branches - NEVER work on main
git checkout -b feature/[issue-number]-[description]

# MANDATORY workflow sequence:
1. Analysis & Planning
2. Branch Creation  
3. Implementation with TodoWrite tracking
4. Build Validation
5. Commit & Push
6. PR Creation
7. Issue Updates
```

#### TodoWrite Integration Patterns

**High-Impact Usage Scenarios**:

- **Complex refactoring**: 3+ component changes
- **Multi-phase implementations**: API + Frontend work
- **Large system changes**: Database + Application updates
- **Pattern replication**: Following proven approaches

**TodoWrite Best Practices**:
```markdown
1. Create 5-8 specific, actionable todos
2. Mark exactly ONE todo as 'in_progress' at a time
3. Complete todos immediately after finishing each step
4. Update progress before moving to next phase
5. Use for stakeholder visibility and accountability
```

### üåø Automated Workflow Implementation

**ENHANCED AUTOMATION**: All development workflows now include full automation to ensure consistent adherence to project guidelines.

#### Enhanced Command Behavior

The following commands now include **FULL WORKFLOW AUTOMATION**:

##### `=impl` Command Enhancement

**Automated Execution Flow:**

```
1. Parse GitHub Task Issue ‚Üí Extract requirements and scope
2. Auto-Branch Creation ‚Üí feature/[issue-number]-[sanitized-description]
3. Implementation Phase ‚Üí Execute planned work with progress tracking
4. Auto-Commit & Push ‚Üí Descriptive commits with proper formatting
5. Auto-PR Creation ‚Üí Comprehensive PR with issue linking
6. Issue Updates ‚Üí Update plan issue with PR link and completion status
7. User Notification ‚Üí Provide PR URL for review and approval
```

##### TodoWrite Integration Enhancement

**Performance Impact from Retrospectives**: 56% faster implementations when TodoWrite is integrated

**Enhanced Implementation Flow with TodoWrite:**
```
1. Parse GitHub Task Issue ‚Üí Extract requirements and scope
2. Initialize TodoWrite ‚Üí Create 5-8 specific, actionable todos
3. Auto-Branch Creation ‚Üí feature/[issue-number]-[sanitized-description]  
4. Implementation Phase ‚Üí Execute with real-time todo tracking
   ‚îú‚îÄ Mark exactly ONE todo as 'in_progress' at a time
   ‚îú‚îÄ Complete todos immediately after finishing each step
   ‚îú‚îÄ Update progress visibility for stakeholders
   ‚îî‚îÄ Ensure accountability for all implementation steps
5. Auto-Commit & Push ‚Üí Descriptive commits with proper formatting
6. Auto-PR Creation ‚Üí Comprehensive PR with issue linking
7. Issue Updates ‚Üí Update plan issue with PR link and completion status
8. TodoWrite Completion ‚Üí Mark all todos as completed
9. User Notification ‚Üí Provide PR URL for review and approval
```

**TodoWrite Performance Benefits:**
- **Visibility**: Real-time progress tracking for stakeholders
- **Accountability**: Prevents skipping critical implementation steps  
- **Focus**: Reduces context switching during complex implementations
- **Efficiency**: Proven 15-minute implementations vs 34-minute baseline
- **Documentation**: Creates audit trail of implementation progress

**High-Impact TodoWrite Usage Patterns:**
```markdown
‚úÖ Complex multi-component refactoring (3+ files)
‚úÖ Full-stack implementations (API + Frontend)
‚úÖ Multi-phase system changes (Database + Application)
‚úÖ Pattern replication following proven approaches
‚úÖ Large refactoring with dependency management

‚ùå Single file edits or trivial changes
‚ùå Simple documentation updates
‚ùå Quick bug fixes without multiple steps
```

##### Branch Naming Convention

- **Format**: `feature/[issue-number]-[sanitized-description]`
- **Example**: `feature/27-deployment-production-implementation`
- **Auto-sanitization**: Removes special characters, converts to kebab-case

##### Commit Message Standards

- **Format**: `[type]: [description] (#[issue-number])`
- **Types**: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`
- **Example**: `feat: implement user authentication system (#25)`

##### Pull Request Automation

- **Title**: Auto-generated from issue title with proper formatting
- **Description**: Includes implementation summary, changes made, and testing notes
- **Issue Linking**: Automatic `Closes #[issue-number]` for proper tracking
- **Labels**: Auto-applied based on implementation type and scope

#### Workflow Safety Measures

- **Branch Protection**: Prevents direct commits to main/master
- **PR Validation**: Ensures all changes go through review process
- **Issue Tracking**: Maintains complete audit trail of work
- **Status Updates**: Real-time progress tracking and notifications

**CRITICAL**: **NEVER** work directly on main/master branch. **ALWAYS** create PRs for review.

### Implementation Guidelines for Automated Workflow

#### Pre-Implementation Checks

- ‚úÖ Verify GitHub Task Issue exists and is properly formatted
- ‚úÖ Ensure no conflicting branches exist
- ‚úÖ Confirm GitHub CLI is authenticated and functional
- ‚úÖ Validate repository permissions for branch creation and PR management

#### Error Handling and Fallbacks

- **Branch Creation Failure**: Falls back to manual branch creation with user guidance
- **Push Failure**: Provides manual push commands and troubleshooting steps
- **PR Creation Failure**: Falls back to manual PR creation with pre-filled templates
- **Issue Update Failure**: Logs error and provides manual update instructions

#### Quality Assurance

- **Code Review**: All PRs require manual review and approval
- **Testing**: Automated tests run on PR creation (if configured)
- **Documentation**: Auto-generated PR descriptions include implementation details
- **Rollback**: Clear instructions for reverting changes if needed

#### Monitoring and Feedback

- **Progress Tracking**: Real-time updates during implementation phases
- **Success Metrics**: PR creation success rate and review completion time
- **User Feedback**: Continuous improvement based on workflow effectiveness
- **Audit Trail**: Complete history of automated actions for debugging

---

## ‚ö° Efficiency Patterns & Performance Optimization

*Based on documented performance improvements from retrospective analysis*

### üèÉ‚Äç‚ôÇÔ∏è 15-Minute Implementation Strategy

**Achieved Results**: Consistent 15-minute implementations vs 34+ minute baseline

#### Prerequisites for High-Speed Implementation
```markdown
‚úÖ Clear reference pattern from previous successful session
‚úÖ TodoWrite tracking system initialized  
‚úÖ Component structure already analyzed
‚úÖ Integration points identified
‚úÖ Success criteria defined
```

#### Speed Optimization Techniques

**1. Pattern Recognition & Replication**
- **Time Savings**: 56% faster when following proven patterns
- **Method**: Use `/docs/retrospective/` files as implementation guides
- **Key**: Adapt existing solutions rather than creating from scratch

**2. MultiEdit for Simultaneous Operations**
```bash
# Instead of multiple single edits:
Edit file ‚Üí Read result ‚Üí Edit file ‚Üí Read result

# Use MultiEdit for simultaneous operations:
MultiEdit with [removal + integration] in single operation
```

**3. Systematic Component Analysis**
```markdown
Phase 1: Quick Analysis (2-3 minutes)
‚îú‚îÄ Read target integration area (lines 250-270)
‚îú‚îÄ Identify removal target (lines 500-545)
‚îú‚îÄ Confirm animation/conditional patterns
‚îî‚îÄ Validate styling consistency approach
```

**4. Build Validation Checkpoints**
```bash
# Critical validation points:
npm run build    # After each major change
npx tsc --noEmit # For type-only validation
```

### üìä Performance Benchmarks

#### Implementation Time Comparisons

| Task Type | First Implementation | Pattern Replication | Improvement |
|-----------|---------------------|-------------------|-------------|
| UI Consolidation | 34 minutes | 15 minutes | 56% faster |
| Component Refactoring | 45 minutes | 20 minutes | 56% faster |
| API Migration | 135 minutes | 75 minutes | 44% faster |
| Database Debugging | 45 minutes | 25 minutes | 44% faster |

#### Efficiency Factor Analysis

**High Efficiency Sessions** (15-20 minutes):
- ‚úÖ TodoWrite usage for progress tracking
- ‚úÖ Reference pattern available
- ‚úÖ Clear component structure understanding
- ‚úÖ Systematic 5-phase approach
- ‚úÖ Proactive build validation

**Low Efficiency Sessions** (45+ minutes):
- ‚ùå No reference pattern
- ‚ùå Schema assumptions without verification  
- ‚ùå Working directly on main branch
- ‚ùå Build testing only at end
- ‚ùå Complex dependency analysis needed

### üéØ High-Impact Optimization Areas

#### 1. TodoWrite Integration ROI
- **Setup Time**: 2-3 minutes
- **Visibility Benefit**: Real-time progress tracking
- **Accountability**: Prevents skipping critical steps
- **Stakeholder Communication**: Clear progress indicators

#### 2. Reference Pattern Utilization
- **Pattern Documentation**: Create detailed retrospectives
- **Pattern Library**: Maintain `/docs/retrospective/` as reference
- **Systematic Replication**: Follow proven approaches exactly
- **Context Adaptation**: Modify only necessary elements

#### 3. Tool Optimization
```bash
# High-efficiency tool combinations:
Read (targeted) ‚Üí MultiEdit (batch changes) ‚Üí Build (validation)

# Avoid inefficient patterns:
Multiple single Edits ‚Üí Multiple Reads ‚Üí Late build testing
```

#### 4. Workflow Adherence
- **Branch Management**: Always create feature branches
- **Incremental Testing**: Build validation at each phase
- **Documentation Standards**: Comprehensive PR descriptions
- **Issue Tracking**: Real-time GitHub issue updates

### üîÑ Continuous Improvement Framework

#### Session Performance Tracking
```markdown
1. Track implementation time per session type
2. Document efficiency factors (TodoWrite, patterns, tools)
3. Identify workflow violations and their impact
4. Measure pattern replication success rates
```

#### Pattern Development Lifecycle
```markdown
1. Novel Implementation ‚Üí Document approach in retrospective
2. Pattern Recognition ‚Üí Identify reusable elements  
3. Pattern Refinement ‚Üí Optimize approach in next similar task
4. Pattern Maturation ‚Üí Achieve consistent sub-20-minute implementations
```

---

## üõ†Ô∏è Development Commands

### Core Development

```bash
# Development server
npm run dev

# Build for production
npm run build

# Start production server
npm start

# Type checking
npm run type-check
```

### Database Management

```bash
# Generate Prisma client
npx prisma generate

# Run database migrations
npx prisma migrate dev

# Reset database
npx prisma migrate reset

# Seed database
npx prisma db seed
```

### AI Prompt Management

```bash
# List all prompts
npm run prompt:list

# Update prompt
npm run prompt:update

# Test prompts
npm run prompt:test

# Analyze prompt performance
npm run prompt:analyze
```

---

## üìà Retrospective Workflow

When you use the `=rrr` command, the agent will create a file and an Issue with the following sections and details:

### Session Retrospective

**Session Date**: [Date in YYYY-MM-DD format, Thailand timezone]
**Start Time**: [HH:MM Thailand time]
**End Time**: [HH:MM Thailand time]
**Duration**: ~X minutes
**Primary Focus**: [Main Focus]
**Current Issue**: #XXX
**Last PR**: #XXX

### Session Summary

[Overall summary of the work done today]

### Timeline

- HH:MM - Start, review issue #XXX (Thailand time)
- HH:MM - [Event] (Thailand time)
- HH:MM - [Event] (Thailand time)
- HH:MM - Work completed (Thailand time)

### Timezone Guidelines for Retrospectives

- **File Naming**: Use `session-YYYY-MM-DD-[description].md` format with Thailand date
- **All Times**: Must be in Thailand timezone (Asia/Bangkok, UTC+7)
- **Date Format**: Christian Era (‡∏Ñ.‡∏®.) in YYYY-MM-DD format
- **Example**: `session-2025-01-25-thailand-timezone-implementation.md`

### üìù AI Diary (REQUIRED - DO NOT SKIP)

**‚ö†Ô∏è MANDATORY**: The agent must write this section in the first person.
[Record initial understanding, how the approach changed, confusing or clarifying points, decisions made, and their reasoning.]

### üí≠ Honest Feedback (REQUIRED - DO NOT SKIP)

**‚ö†Ô∏è MANDATORY**: The agent must honestly evaluate its performance in this section.
[Assess the session's overall efficiency, tools and their limitations, clarity of communication, and suggestions for improvement.]

### What Went Well

- The successes that occurred

### What Could Improve

- Areas that could be made better

### Blockers & Resolutions

- **Blocker**: Description of the obstacle
  **Resolution**: The solution implemented

### Lessons Learned

- **Pattern**: [Pattern discovered] - [Reason why it's important]
- **Mistake**: [Mistake made] - [How to avoid it]
- **Discovery**: [New finding] - [How to apply it]

---

## üìö Best Practices from Retrospectives

*This section incorporates lessons learned from 10+ development sessions documented in `/docs/retrospective/`*

### üéØ TodoWrite Integration Best Practices

Based on proven results showing **15-minute implementations** vs 34+ minute sessions:

#### When to Use TodoWrite
- **Complex multi-step tasks** requiring 3+ distinct phases
- **Multi-component refactoring** (e.g., UI consolidation patterns)
- **Full-stack implementations** spanning API and frontend changes
- **Large refactoring projects** with dependency management needs

#### TodoWrite Workflow Pattern
```markdown
1. Phase Planning: Break complex tasks into 5-8 manageable todos
2. Progress Tracking: Mark each todo in_progress ‚Üí completed as work progresses
3. Visibility: Provides real-time progress visibility for stakeholders
4. Accountability: Ensures no steps are skipped in complex workflows
```

#### Proven Efficiency Gains
- **Pattern Replication**: 56% faster implementation (15 min vs 34 min) when following proven patterns
- **Progress Visibility**: Reduces context switching and improves focus
- **Systematic Approach**: Prevents missing critical implementation steps

### üîÑ Pattern Replication Strategy

#### Reference Implementation Approach
1. **Document Successful Patterns**: Create detailed retrospectives for reusable approaches
2. **Systematic Replication**: Use previous session files as implementation guides
3. **Adapt, Don't Recreate**: Modify proven patterns for new contexts
4. **Measure Efficiency**: Track implementation time improvements

#### Proven Pattern Examples
- **UI Consolidation**: Reward card ‚Üí chip integration (achieved 56% speed improvement)
- **Component Refactoring**: Systematic removal and integration approaches
- **API Updates**: Phase-by-phase endpoint migration strategies

### ‚ö° Build Validation Checkpoints

#### Critical Validation Points
```bash
# After schema changes
npm run build && npx tsc --noEmit

# After API modifications
npm run build 2>&1 | grep -A 5 "error"

# After large refactoring
npx prisma generate && npm run build
```

#### Proactive Testing Strategy
- **Incremental Builds**: Test builds after each major change, not just at the end
- **TypeScript Validation**: Run `npx tsc --noEmit` for pure type checking
- **Dependency Verification**: Check imports and exports after file restructuring
- **Database Sync**: Verify `npx prisma generate` after schema changes

### üóÑÔ∏è Schema Investigation Protocol

#### Before Implementation Checklist
1. **Verify Database Schema**: Always check actual Prisma schema definitions
2. **Trace Data Structures**: Follow interface definitions through the codebase
3. **Validate Field Names**: Don't assume field naming conventions
4. **Check Relationships**: Understand model relationships before querying

#### Common Schema Pitfalls
- **Assumption Errors**: Making assumptions about field names/structures
- **Interface Misalignment**: Frontend interfaces not matching database schema
- **Relationship Complexity**: Not understanding foreign key relationships
- **Type Mismatches**: TypeScript interfaces not reflecting actual data structures

### üîß Multi-Phase Implementation Approach

#### Systematic Phase Breakdown
```
Phase 1: Analysis & Preparation (10-15% of time)
Phase 2: Core Implementation (40-50% of time)  
Phase 3: Integration & Testing (25-30% of time)
Phase 4: Documentation & Cleanup (10-15% of time)
```

#### Phase Management Best Practices
- **Clear Phase Objectives**: Define specific deliverables for each phase
- **Dependency Mapping**: Identify cross-phase dependencies upfront
- **Progress Checkpoints**: Validate phase completion before proceeding
- **Issue Tracking**: Update GitHub issues after each phase completion

### üõ°Ô∏è Database Best Practices

#### PostgreSQL Sequence Management
```sql
-- Check sequence current value
SELECT last_value FROM "Pack_id_seq";

-- Reset sequence to match data
SELECT setval('"Pack_id_seq"', (SELECT MAX(id) FROM "Pack") + 1);

-- Fix auto-increment synchronization
SELECT setval('"TableName_id_seq"', COALESCE(MAX(id), 0) + 1) FROM "TableName";
```

#### Debugging Strategy
1. **Temporary Scripts**: Create debugging scripts instead of modifying main code
2. **Isolation Testing**: Test specific database operations in isolation
3. **Sequence Verification**: Check auto-increment sequences after data manipulation
4. **Transaction Safety**: Use transactions for multi-step database operations

### üìù Documentation Standards

#### PR Description Requirements
- **Implementation Summary**: Clear overview of changes made
- **Technical Details**: Specific technical implementation notes
- **Before/After Analysis**: Impact assessment and improvement metrics
- **Testing Validation**: Build success and functionality verification

#### Retrospective Documentation
- **AI Diary**: First-person reflection on approach and decision-making
- **Honest Feedback**: Critical assessment of session efficiency and quality
- **Pattern Recognition**: Identification of reusable patterns and approaches
- **Lessons Learned**: Specific insights for future implementation improvement

---

## üîß Troubleshooting

### Common Issues

#### Build Failures

```bash
# Check for type errors or syntax issues
npm run build 2>&1 | grep -A 5 "error"

# Clear cache and reinstall dependencies
rm -rf node_modules .next .cache
npm install

# Reset Prisma client
npx prisma generate
```

#### Database Issues

```bash
# Reset database connection
npx prisma db push --force-reset

# Check database connection
npx prisma db pull

# Regenerate Prisma client
npx prisma generate
```

#### PostgreSQL Sequence Issues

*From retrospective: "Auto-increment sequences can become desynchronized in PostgreSQL"*

**Common symptoms:**
- Unique constraint violations on primary key fields during seeding
- Database insertion failures with "duplicate key value violates unique constraint"
- Auto-increment sequence out of sync with actual data

**Diagnosis and Resolution:**
```sql
-- Check current sequence value
SELECT last_value FROM "TableName_id_seq";

-- Check maximum ID in table
SELECT MAX(id) FROM "TableName";

-- Reset sequence to match data (if sequence < max ID)
SELECT setval('"TableName_id_seq"', COALESCE(MAX(id), 0) + 1) FROM "TableName";

-- Example for Pack table:
SELECT setval('"Pack_id_seq"', (SELECT MAX(id) FROM "Pack") + 1);
```

**Prevention strategies:**
- Always reset sequences after manual data insertion
- Use `COALESCE(MAX(id), 0) + 1` to handle empty tables
- Check sequence synchronization after database migrations
- Create debugging scripts for complex sequence issues

#### TypeScript Compilation Errors

*From retrospective: "Schema investigation prevents TypeScript errors"*

**Common Interface Misalignments:**
```bash
# Check actual Prisma schema before assuming field names
cat prisma/schema.prisma | grep -A 10 "model ModelName"

# Verify TypeScript interface alignment
npx tsc --noEmit --strict

# Generate fresh Prisma types
npx prisma generate && npx tsc --noEmit
```

**Schema Investigation Protocol:**
1. **Never assume field names** - Always check actual schema definitions
2. **Trace data structures** - Follow interfaces through `useProfile` hooks and API responses
3. **Verify relationships** - Check foreign key relationships in Prisma schema
4. **Test incremental changes** - Run type checking after each interface modification

**Common pitfalls from retrospectives:**
- Assuming `coins` field exists directly when it's actually `totalCoins` in stats object
- Using `value` field instead of `rewards` structure in RewardConfiguration
- Interface mismatches between API responses and frontend expectations

#### AI System Issues

```bash
# Test AI providers
npm run prompt:test

# Check API keys
echo $OPENAI_API_KEY | head -c 10
echo $GOOGLE_GENERATIVE_AI_API_KEY | head -c 10

# Verify prompt encryption
npm run prompt:list
```

#### Port Conflicts

```bash
# Find the process using port 3000
lsof -i :3000

# Kill the process
kill -9 [PID]

# Use alternative port
npm run dev -- -p 3001
```

#### Payment System Issues

```bash
# Test Stripe webhook
stripe listen --forward-to localhost:3000/api/payments/webhook

# Verify Stripe keys
echo $STRIPE_SECRET_KEY | head -c 10
echo $STRIPE_WEBHOOK_SECRET | head -c 10
```

### Performance Monitoring

- **Core Web Vitals**: Monitor LCP (<2.5s), FID (<100ms), CLS (<0.1)
- **API Response Times**: Target <500ms average
- **Database Queries**: Monitor slow queries via Prisma logs
- **AI Response Times**: Track LLM provider performance
- **Error Rates**: Monitor via Vercel analytics and custom logging
